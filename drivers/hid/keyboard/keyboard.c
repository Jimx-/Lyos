/*  This file is part of Lyos.

    Lyos is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Lyos is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Lyos.  If not, see <http://www.gnu.org/licenses/>. */

#include <lyos/type.h>
#include <lyos/ipc.h>
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <lyos/const.h>
#include <string.h>
#include <lyos/fs.h>
#include <lyos/proc.h>
#include <lyos/global.h>
#include <lyos/proto.h>
#include <lyos/interrupt.h>
#include <lyos/portio.h>
#include <lyos/service.h>
#include <lyos/input.h>
#include <libinputdriver/libinputdriver.h>

#include "keyboard.h"

PRIVATE struct kb_inbuf kb_in;
PRIVATE int code_with_E0;
PUBLIC irq_id_t kb_irq_set;
PRIVATE int kb_hook_id;

PRIVATE int processing = 0;

PRIVATE int init_keyboard();
PRIVATE void keyboard_process();
PRIVATE void keyboard_interrupt(unsigned long irq_set);
PRIVATE u8 get_byte_from_kb_buf();
PRIVATE void set_leds();
PRIVATE void kb_wait();
PRIVATE void kb_ack();

PRIVATE struct inputdriver keyboard_driver = {
    .input_interrupt = keyboard_interrupt,
};

/*****************************************************************************
 *                               main
 *****************************************************************************/
/**
 * The main loop.
 *
 *****************************************************************************/
PUBLIC int main()
{
    serv_register_init_fresh_callback(init_keyboard);
    serv_init();

    return inputdriver_start(&keyboard_driver);
}

/*****************************************************************************
 *                                keyboard_handler
 *****************************************************************************/
/**
 * <Ring 0> Handles the interrupts generated by the keyboard controller.
 *
 * @param irq The IRQ corresponding to the keyboard, unused here.
 *****************************************************************************/
PRIVATE void keyboard_interrupt(unsigned long irq_set)
{
    u8 scan_code;
    portio_inb(KB_DATA, &scan_code);

    if (kb_in.count < KB_IN_BYTES) {
        *(kb_in.p_head) = scan_code;
        kb_in.p_head++;
        if (kb_in.p_head == kb_in.buf + KB_IN_BYTES) kb_in.p_head = kb_in.buf;
        kb_in.count++;
    }

    if (!processing) keyboard_process();
}

/*****************************************************************************
 *                                init_keyboard
 *****************************************************************************/
/**
 * <Ring 1> Initialize some variables and set keyboard interrupt handler.
 *
 *****************************************************************************/
PRIVATE int init_keyboard()
{
    kb_in.count = 0;
    kb_in.p_head = kb_in.p_tail = kb_in.buf;

    set_leds();

    kb_irq_set = 1 << KEYBOARD_IRQ;
    kb_hook_id = KEYBOARD_IRQ;

    irq_setpolicy(KEYBOARD_IRQ, IRQ_REENABLE, &kb_hook_id);
    irq_enable(&kb_hook_id);

    return 0;
}

/*****************************************************************************
 *                                keyboard_read
 *****************************************************************************/
/**
 * Read a character from keyboard.
 *
 *****************************************************************************/
PRIVATE void keyboard_process()
{
    u8 scan_code;

    /**
     * 1 : make
     * 0 : break
     */
    int make;

    /**
     * We use a integer to record a key press.
     * For instance, if the key HOME is pressed, key will be evaluated to
     * `HOME' defined in keyboard.h.
     */
    u32 key = 0;

    processing = 1;
    while (kb_in.count > 0) {
        code_with_E0 = 0;
        scan_code = get_byte_from_kb_buf();

        /* parse the scan code below */
        if (scan_code == 0xE1) {
            int i;
            u8 pausebreak_scan_code[] = {0xE1, 0x1D, 0x45, 0xE1, 0x9D, 0xC5};
            int is_pausebreak = 1;
            for (i = 1; i < 6; i++) {
                if (get_byte_from_kb_buf() != pausebreak_scan_code[i]) {
                    is_pausebreak = 0;
                    break;
                }
            }
            if (is_pausebreak) {
                key = KEY_PAUSE;
            }
        } else if (scan_code == 0xE0) {
            code_with_E0 = 1;
            scan_code = get_byte_from_kb_buf();

            /* PrintScreen is pressed */
            if (scan_code == 0x2A) {
                code_with_E0 = 0;
                if ((scan_code = get_byte_from_kb_buf()) == 0xE0) {
                    code_with_E0 = 1;
                    if ((scan_code = get_byte_from_kb_buf()) == 0x37) {
                        key = KEY_SYSRQ;
                        make = 1;
                    }
                }
            }
            /* PrintScreen is released */
            else if (scan_code == 0xB7) {
                code_with_E0 = 0;
                if ((scan_code = get_byte_from_kb_buf()) == 0xE0) {
                    code_with_E0 = 1;
                    if ((scan_code = get_byte_from_kb_buf()) == 0xAA) {
                        key = KEY_SYSRQ;
                        make = 0;
                    }
                }
            }
        }

        if ((key != KEY_PAUSE) && (key != KEY_SYSRQ)) {

            /* make or break */
            make = (scan_code & FLAG_BREAK ? 0 : 1);

            key = scan_code & ~FLAG_BREAK;
        }

        inputdriver_send_event(EV_KEY, key, make);
    }

    processing = 0;
}

/*****************************************************************************
 *                                get_byte_from_kb_buf
 *****************************************************************************/
/**
 * Read a byte from the keyboard buffer.
 *
 * @return The byte read.
 *****************************************************************************/
PRIVATE u8 get_byte_from_kb_buf()
{
    u8 scan_code;

    /* while (kb_in.count <= 0) { */
    /* } /\* wait for a byte to arrive *\/ */

    scan_code = *(kb_in.p_tail);
    kb_in.p_tail++;
    if (kb_in.p_tail == kb_in.buf + KB_IN_BYTES) {
        kb_in.p_tail = kb_in.buf;
    }
    kb_in.count--;

    return scan_code;
}

/*****************************************************************************
 *                                kb_wait
 *****************************************************************************/
/**
 * Wait until the input buffer of 8042 is empty.
 *
 *****************************************************************************/
PRIVATE void kb_wait()
{
    u8 kb_stat;

    do {
        portio_inb(KB_CMD, &kb_stat);
    } while (kb_stat & 0x02);
}

/*****************************************************************************
 *                                kb_ack
 *****************************************************************************/
/**
 * Read from the keyboard controller until a KB_ACK is received.
 *
 *****************************************************************************/
PRIVATE void kb_ack()
{
    u8 kb_read;

    do {
        portio_inb(KB_DATA, &kb_read);
    } while (kb_read != KB_ACK);
}

/*****************************************************************************
 *                                set_leds
 *****************************************************************************/
/**
 * Set the leds according to: caps_lock, num_lock & scroll_lock.
 *
 *****************************************************************************/
PRIVATE void set_leds()
{
    u8 leds = 0;
    // u8 leds = (caps_lock << 2) | (num_lock << 1) | scroll_lock;

    kb_wait();
    portio_outb(KB_DATA, LED_CODE);
    kb_ack();

    kb_wait();
    portio_outb(KB_DATA, leds);
    kb_ack();
}
